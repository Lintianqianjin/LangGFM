from .base_ssl import SelfSupervisedGraphTask
import networkx as nx
import random


@SelfSupervisedGraphTask.register("gae_autoencoder")
class TopologyAutoencoder(SelfSupervisedGraphTask):
    def __init__(self, distinguish_directions: bool = False):
        """
        Initialize the TopologyAutoencoder.

        Args:
            distinguish_directions (bool): Whether to distinguish between predecessors and successors.
                                           Only applicable for directed graphs.
        """
        self.distinguish_directions = distinguish_directions

    def modify_graph(self, graph: nx.Graph) -> nx.Graph:
        """
        For this task, the graph is used as-is without modifications.

        Args:
            graph (nx.Graph): The input NetworkX graph.

        Returns:
            nx.Graph: The unmodified graph.
        """
        return graph

    def generate_query(self, graph: nx.Graph) -> dict:
        """
        Randomly select a node as the query and format it as natural language.

        Args:
            graph (nx.Graph): The input NetworkX graph.

        Returns:
            dict: A dictionary containing:
                  - 'node': The randomly selected node.
                  - 'distinguish_directions': Whether to distinguish between predecessors and successors.
                  - 'query_text': The natural language query text.
        """
        node = random.choice(list(graph.nodes))
        if self.distinguish_directions:
            query_text = (
                f"Please identify all predecessors and successors of the node {node} respectively "
                "in the graph. Ensure that predecessors and successors are stored in two separate lists, "
                "and each list is sorted in ascending order by node id."
            )
        else:
            query_text = (
                f"Please identify all neighbors of the node {node} in the graph, "
                "including both predecessor and successor nodes. "
                "Ensure that the neighbors are stored in a list sorted in ascending order by node id."
            )
        return {
            "query_node": node,
            "distinguish_directions": self.distinguish_directions,
            "query_text": query_text,
        }

    def generate_answer(self, graph: nx.Graph, query: dict) -> str:
        """
        Generate the answer for the query in natural language format.

        Args:
            graph (nx.Graph): The input NetworkX graph.
            query (dict): The structured query generated by `generate_query`.

        Returns:
            str: The natural language answer.
        """
        node = query["query_node"]

        if query["distinguish_directions"]:
            # For directed graphs, distinguish predecessors and successors
            predecessors = sorted(graph.predecessors(node))
            successors = sorted(graph.successors(node))
            if not predecessors and not successors:
                return f"The node {node} has no predecessors and no successors."
            elif not predecessors:
                return f"The node {node} has no predecessors. The successors are stored in the list: {successors}."
            elif not successors:
                return f"The node {node} has no successors. The predecessors are stored in the list: {predecessors}."
            else:
                return (
                    f"The predecessors of node {node} are stored in the list: {predecessors}, "
                    f"and the successors are stored in the list: {successors}."
                )
        else:
            # For undirected graphs or when not distinguishing directions
            neighbors = sorted(nx.all_neighbors(graph,node))
            if not neighbors:
                return f"The node {node} has no neighbors."
            else:
                return (
                    f"The neighbors of node {node}, including both predecessor and successor nodes, "
                    f"are stored in the list: {neighbors}."
                )   